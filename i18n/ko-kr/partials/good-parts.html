<h3>Object Oriented</h3>

<p>
    JavaScript has strong object-oriented programming capabilities, even though some debates have taken place due to the differences in object-oriented JavaScript compared to other languages.
</p>

<p class="source">
    Source: <a target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Introduction_to_Object-Oriented_JavaScript">Introduction to Object-Oriented JavaScript</a>
</p>

<h3>Anonymous Functions</h3>

<p>
    Anonymous functions are functions that are dynamically declared at runtime. They’re called anonymous functions because they aren’t given a name in the same way as normal functions.
</p>

<p class="source">
    Source: <a target="_blank" href="http://helephant.com/2008/08/23/javascript-anonymous-functions/">JavaScript anonymous functions</a>
</p>

<h3>Functions as First-class Objects</h3>

<p>
    Functions in JavaScript are first class objects. This means that JavaScript functions are just a special type of object that can do all the things that regular objects can do.
</p>

<p class="source">
    Source: <a target="_blank" href="http://helephant.com/2008/08/19/functions-are-first-class-objects-in-javascript/">Functions are first class objects in JavaScript</a>
</p>

<h3>Loose Typing</h3>

<p>
    For many front-end developers, JavaScript was their first taste of a scripting and/or interpretive language. To these developers, the concept and implications of loosely typed variables may be second nature. However, the explosive growth in demand for modern web applications has resulted in a growing number of back-end developers that have had to dip their feet into the pool of client-side technologies. Many of these developers are coming from a background of strongly typed languages, such as C# or Java, and are unfamiliar with both the freedom and the potential pitfalls involved in working with loosely typed variables.
</p>

<p class="source">
    Source: <a target="_blank" href="http://blog.jeremymartin.name/2008/03/understanding-loose-typing-in.html">Understanding Loose Typing in JavaScript</a>
</p>

<h3>Scoping and Hoisting</h3>

<p>
    <b>스코핑:</b> JavaScript에서는, 함수가 <i>사실 상의</i> 변수들의 스코프 범위입니다. 그 말인 즉슨, 루프나 조건문(if, for, while, switch, try같은)의 블럭은 다른 언어들과는 다르게 스코프 범위가 아닙니다. 그러므로, 함수와 그 함수 내에 있는 블럭들은 같은 스코프를 사용합니다. 이렇기 때문에, 변수가 블락 내에서만 존재할거라 생각하고 변수를 선언하는 것은 위험할 수도 있습니다.
</p>

<p>
    <b>호이스팅:</b> 런타임에서, 모든 변수와 함수의 선언은 각 함수(스코프)의 가장 위로 옮겨집니다. 이것이 바로 호이스팅입니다. 이것 때문에, 첫 줄 이후에 선언 된 변수들은 호이스팅으로 인해 선언한 곳 전부터 존재하게 됩니다. 실수를 피하기 위해 모든 변수를 제일 첫 줄에 함께 선언하는 것은 좋은 습관입니다. 이것은 블럭 스코프 기반 언어를 사용하던 프로그래머들이 흔하게 겪는 문제입니다.
</p>

<p class="source">
    Source: <a target="_blank" href="http://www.adequatelygood.com/JavaScript-Scoping-and-Hoisting.html">JavaScript Scoping and Hoisting</a>
</p>

<h3>Function Binding</h3>

<p>
    함수 바인딩은 처음 JavaScript를 시작할 때에는 아마 거의 신경 쓸 일이 없을지도 모릅니다. 하지만 다른 함수 내에서 this의 context를 유지해야 할 일이 생겼을 때 당신이 정말 필요로 하는 것은 <b>Function.prototype.bind()</b>라는 걸 알게 될 겁니다.
</p>

<p class="source">
    Source: <a target="_blank" href="http://coding.smashingmagazine.com/2014/01/23/understanding-javascript-function-prototype-bind/">Understanding JavaScript’s Function.prototype.bind</a>
</p>

<h3>Closure Function</h3>

<p>
    Closures are functions that refer to independent (free) variables. In other words, the function defined in the closure 'remembers' the environment in which it was created in.
It is an important concept to understand as it can be useful during development, like emulating private methods. It can also help to learn how to avoid common mistakes, like creating closures in loops.
 </p>

<p class="source">
    Source: <a target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Closures/">MDN - Closures</a>
</p>

<h3>Strict mode</h3>

<p>
    ECMAScript 5's strict mode is a way to opt in to a restricted variant of JavaScript. Strict mode isn't just a subset: it intentionally has different semantics from normal code. Browsers not supporting strict mode will run strict mode code with different behavior from browsers that do, so don't rely on strict mode without feature-testing for support for the relevant aspects of strict mode. Strict mode code and non-strict mode code can coexist, so scripts can opt into strict mode incrementally.
 </p>

<p class="source">
    Source: <a target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions_and_function_scope/Strict_mode/">MDN - Strict mode</a>
</p>

<h3>Immediately-Invoked Function Expression (IIFE)</h3>

<p>
   An immediately-invoked function expression is a pattern which produces a lexical scope using JavaScript's function scoping. Immediately-invoked function expressions can be used to avoid variable hoisting from within blocks, protect against polluting the global environment and simultaneously allow public access to methods while retaining privacy for variables defined within the function.<br/><br/>
   <i>This pattern has been referred to as a self-executing anonymous function, but <a target="_blank" href="http://twitter.com/cowboy">@cowboy</a> (Ben Alman) introduced the term IIFE as a more semantically accurate term for the pattern</i>.
</p>

<p class="source">
    Source: <a target="_blank" href="http://benalman.com/news/2010/11/immediately-invoked-function-expression/">Immediately-Invoked Function Expression (IIFE)</a>
</p>
