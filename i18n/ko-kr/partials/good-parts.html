<h3>Object Oriented</h3>

<p>
    JavaScript는 객체지향 프로그래밍에 강력한 호환성을 제공하고 있지만, 그럼에도 불구하고 타 객체 지향 언어와 비교했을 때 다른 점으로 인해 자주 논의됩니다.
</p>

<p class="source">
    참고: <a target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Introduction_to_Object-Oriented_JavaScript">Introduction to Object-Oriented JavaScript</a>
</p>

<h3>익명 함수</h3>

<p>
    익명 함수는 런타임 시 동적으로 선언되는 함수입니다. 이런 함수를 익명함수라 하는데 다른 평범한 함수와는 달리 이름이 주어지지 않기 때문입니다.
</p>

<p class="source">
    참고: <a target="_blank" href="http://helephant.com/2008/08/23/javascript-anonymous-functions/">JavaScript anonymous functions</a>
</p>

<h3>1급 객체로서의 함수</h3>

<p>
    JavaScript에서 함수는 1급 객체입니다. 다시 말해 JavaScript 함수는 특별한 타입의 객체로, 일반적인 객체가 할 수 있는 모든 일을 할 수 있다는 뜻입니다.
</p>

<p class="source">
    참고: <a target="_blank" href="http://helephant.com/2008/08/19/functions-are-first-class-objects-in-javascript/">Functions are first class objects in JavaScript</a>
</p>

<h3>느슨한 타입</h3>

<p>
  많은 프론트엔드 개발자들에게 JavaScript는 처음으로 접하는 인터프리터 언어이자 스크립트 언어다. 이 개발자들에게 느슨한 타입의 변수라는 개념과 논리적 함축은 당연할 수 있는 일이다. 하지만 모던 웹 어플리케이션에 대한 수요가 폭발적으로 증가함에 따라 클라이언트측 기술에 발을 디딘 백엔드 개발자들도 점점 많아지고 있는데, C#이나 Java같은 강한 타입의 언어를 알고 있는 이 사람들에게는 느슨한 타입의 변수들이 주는 자유로움이나 잠재적인 함정들이 익숙하지 않다.
</p>

<p class="source">
    참고: <a target="_blank" href="http://blog.jeremymartin.name/2008/03/understanding-loose-typing-in.html">Understanding Loose Typing in JavaScript</a>
</p>

<h3>스코핑과 호이스팅</h3>

<p>
    <b>스코핑:</b> JavaScript에서는, 함수가 <i>사실 상의</i> 변수들의 스코프 범위입니다. 그 말인 즉슨, 루프나 조건문(if, for, while, switch, try같은)의 블럭은 다른 언어들과는 다르게 스코프 범위가 아닙니다. 그러므로, 함수와 그 함수 내에 있는 블럭들은 같은 스코프를 사용합니다. 이렇기 때문에, 변수가 블럭 내에서만 존재할거라 생각하고 변수를 선언하는 것은 위험할 수도 있습니다.
</p>

<p>
    <b>호이스팅:</b> 런타임에서, 모든 변수와 함수의 선언은 각 함수(스코프)의 가장 위로 옮겨집니다. 이것이 바로 호이스팅입니다. 이것 때문에, 첫 줄 이후에 선언 된 변수들은 호이스팅으로 인해 선언한 곳 전부터 존재하게 됩니다. 실수를 피하기 위해 모든 변수를 제일 첫 줄에 함께 선언하는 것은 좋은 습관입니다. 이것은 블럭 스코프 기반 언어를 사용하던 프로그래머들이 흔하게 겪는 문제입니다.
</p>

<p class="source">
    참고: <a target="_blank" href="http://www.adequatelygood.com/JavaScript-Scoping-and-Hoisting.html">JavaScript Scoping and Hoisting</a>
</p>

<h3>Function Binding</h3>

<p>
    함수 바인딩은 처음 JavaScript를 시작할 때에는 아마 거의 신경 쓸 일이 없을지도 모릅니다. 하지만 다른 함수 내에서 this의 context를 유지해야 할 일이 생겼을 때 당신이 정말 필요로 하는 것은 <b>Function.prototype.bind()</b>라는 걸 알게 될 겁니다.
</p>

<p class="source">
    참고: <a target="_blank" href="http://coding.smashingmagazine.com/2014/01/23/understanding-javascript-function-prototype-bind/">Understanding JavaScript’s Function.prototype.bind</a>
</p>

<h3>Closure Function</h3>

<p>
  클로저는 독립적인(자유로운) 변수들을 가리키는 함수들이다. 다시 말하자면, 클로저 안에서 정의한 함수는 클로저 안에서 정의한 함수는 만들어진 환경을 '기억한다'.
프라이빗 메소드를 흉내내는 것처럼 개발할 때 유용한만큼 이해하는게 중요한 개념이다. 또한 반복문 안에서 클로저를 생성하는 것처럼, 흔히 하는 실수들을 어떻게 피할 수 있는지도 알 수 있다.
 </p>

<p class="source">
    참고: <a target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Closures/">MDN - Closures</a>
</p>

<h3>Strict 모드</h3>

<p>
  ECMAScript 5의 strict 모드는 JavaScript의 제한된 변형을 사용하는 방법이다. 단순히 부분집합은 아니다: 의도적으로 일반 코드와 다른 의미를 갖는다. Strict 모드를 지원하지 않는 브라우져는 지원하는 브라우져와 다르게 strict 모드 코드를 실행하므로, strict 모드에 대해 적절하게 지원되는지 기능 테스트가 없다면 신뢰할 수 없다. Strict 모드와 비Strict 모드의 코드는 동시에 존재할 수 있으므로, 계속해서 strict 모드를 명시해야 한다.
</p>

<p class="source">
    참고: <a target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions_and_function_scope/Strict_mode/">MDN - Strict mode</a>
</p>

<h3>즉시실행 함수 표현식(Immediately-Invoked Function Expression; IIFE)</h3>

<p>
   즉시실행 함수 표현식은 JavaScript의 함수 스코핑을 사용해서 렉시컬 스코프를 생성하는 패턴이다. 즉시실행 함수 표현식은 블락 내에서 변수가 호이스팅되는걸 방지하거나 전역 환경이 오염되는걸 보호하는데 사용되기도 하며, 동시에 함수 내에서 정의된 변수를 private로 만들며 메소드만 접근하도록 만들수도 있다.
   <i>이 패턴은 자기실행 익명 함수(self-executing anonymous function)이라고 불리기도 하지만, <a target="_blank" href="http://twitter.com/cowboy">@cowboy</a> (Ben Alman)이 패턴에 대해 의미적으로 더 정확한 단어로 IIFE를 소개했다.
</p>

<p class="source">
    참고: <a target="_blank" href="http://benalman.com/news/2010/11/immediately-invoked-function-expression/">Immediately-Invoked Function Expression (IIFE)</a>
</p>
